// This codes use HAPRAD and the histograms generated by PhiHist.cpp to calculate the RC factors
// Return the Rc facotors in Phi histograms, one for each 4Dim bin of Q2, Nu, Zh, Pt2
// Can be compiled using Make, but you need to compile HAPRAD before
// For the target name use (C,Fe,Pb) for the solids targets and (DC,DFe,DPb) for the liquid target

#include <fstream>
#include <iostream>
#include <string>
#include "TString.h"
#include "TRadCor.h"
#include "TFile.h"
#include "TROOT.h"
#include "TNtuple.h"
#include "TMath.h"
#include "TH1.h"
#include "TFile.h"
#include "TStopwatch.h"
#include "haprad_constants.h"
#include "Binning_Rc.h"


int main(int argc, char* argv[]) {

  if(argc != 5) {
    std::cout << "Insert (just) the target name as a parameter" << std::endl;
    return 0;
  }

  TStopwatch t;

  std::cout << "Start" << std::endl;

  const TString dataDirectory  = "/home/matias/proyecto/Pt2Broadening_multi-pion/Data/";
  const TString inputDirectory  = "/home/matias/proyecto/TwoPionAnalysis/Data/Nominal/";
  const TString outputDirectory = "/home/matias/proyecto/TwoPionAnalysis/Data/Nominal/";
  
  std::string target = argv[1];
  int nPion = (int)*argv[2] - 48;
  int Q2BinSelect = (int)*argv[3] - 48;
  int NuBinSelect = (int)*argv[4] - 48;
  //int ZhBinSelect = (int)*argv[5] - 48;
  std::cout << "N PION = " << nPion << std::endl;
  std::cout << "Q2 bin = " << Q2BinSelect << std::endl;
  std::cout << "Nu bin = " << NuBinSelect << std::endl;
  //std::cout << "Zh bin = " << NuBinSelect << std::endl;
  // Creating a array of chars instead of a string to use Form method
  int n = target.length();
  char targetArr[n + 1];
  strcpy(targetArr, target.c_str());

  Double_t f1;
  // Double_t f3;
  Double_t NAZ;
  Double_t m = TMath::Power((kMassNeutron + kMassPion), 2);
  //float Masa = 0.938; // Mass Nucleon (Proton)
  Double_t a1, a2, a3;
  //int sysReturn;

  TRadCor rc;
  a1 = 1;
  a2 = 0;
  a3 = a1/a2;

  if(target == "C")        NAZ = 0.5;
  else if(target == "Fe")  NAZ = 0.5;
  else if(target == "Pb")  NAZ = 82./208.;
  else if(target == "DC")  NAZ = 0.5;
  else if(target == "DFe") NAZ = 0.5;
  else if(target == "DPb") NAZ = 0.5; 
  else NAZ = 0.5;

  TH1F* histRcFactors  = new TH1F("RcFactors", "", N_Phi, -180, 180);

  TFile* fileBins = new TFile(Form(inputDirectory + "Centroid_%s.root", targetArr), "READ");
  TNtuple* ntupleBins = (TNtuple*) fileBins->Get(Form("Centroid_%i", nPion));
  gROOT->cd();
  float Q2, Xb, Zh, Pt, Phi;
  float Q2Bin, NuBin, ZhBin, Pt2Bin;

  ntupleBins->SetBranchAddress("Q2", &Q2);
  ntupleBins->SetBranchAddress("Xb", &Xb);
  ntupleBins->SetBranchAddress("Zh", &Zh);
  ntupleBins->SetBranchAddress("Pt", &Pt);
  ntupleBins->SetBranchAddress("Q2Bin",  &Q2Bin);
  ntupleBins->SetBranchAddress("NuBin",  &NuBin);
  ntupleBins->SetBranchAddress("ZhBin",  &ZhBin);
  ntupleBins->SetBranchAddress("Pt2Bin", &Pt2Bin);


  gROOT->cd();
  TFile* outputFile = new TFile(outputDirectory + Form("RcFactors_%s_%i%i%i_%i.root", targetArr, 
	                                (int)Q2Bin, (int)NuBin, (int)ZhBin, nPion), "RECREATE");
  gROOT->cd();
  for(int i = 0; i < ntupleBins->GetEntries(); i++) {
    ntupleBins->GetEntry(i);
    if((int)Q2Bin != Q2BinSelect || (int)NuBin != NuBinSelect) { continue; } 
    for(int PhiCounter = 0 ; PhiCounter < N_Phi ; PhiCounter++) { // Loops in every Phi bin

      Phi = (Phi_BINS[PhiCounter] + Phi_BINS[PhiCounter+1])/2;
      rc.CalculateRCFactor(5.015, Xb, Q2, Zh, Pt, Phi, m, NAZ);
      f1 = rc.GetFactor1();
      // f3 = rc.GetFactor3();
      if(TMath::IsNaN(f1) || f1 == a3) f1 = 0;
      // if(TMath::IsNaN(f3) || f3 == a3) f3 = 0;
      std::cout << "El Factor es: " << f1 << std::endl;
      histRcFactors->SetBinContent(PhiCounter + 1, f1);
    }// End Phi loop

    outputFile->cd();
    histRcFactors->Write(Form("RcFactor_%s_%i%i%i%i_%i", targetArr, (int)Q2Bin, (int)NuBin, 
			      (int)ZhBin, (int)Pt2Bin, nPion));
    histRcFactors->Reset();
    gROOT->cd();

    }
    delete ntupleBins;
    fileBins->Close();

  outputFile->Close();
  t.Print();
  return 0;
}

